# File System / Disk Management

## File System

#### 파일 시스템이란?

파일 시스템을 구현하기 위한 자료구조?

성능을 높이기 위해서 어떻게 해야 하는지?



#### 파일 시스템이 필요한 이유?

컴퓨터에서 어플리케이션이 돌아갈 때 데이터를 저장하는 공간이 필요

RAM에 저장하면 다 날라감

가상 메모리 크기는 제한적

내가 만든 데이터를 다른 사람들이 볼 수 있도록

정보를 저장하는 persistent한 공간을 만듬

아주 큰 정보도 저장 가능

그 정보를 file이란 구조에 집어넣고 읽고 쓰면서 정보를 공유

운영체제 안에 파일을 관리하는 것 => 파일 시스템



#### 파일 시스템의 기능

파일 구성 : 사용자의 요구에 따라 파일과 디렉토리를 만듬

파일 관리 : 파일 생성, 수정, 삭제

접근 권한 관리 : 다른 사용자로부터 파일을 보호

접근 방법 제공 : 사용자에게 파일을 읽고 쓰고 실행할 수 있도록 방법 제공

무결성 보장 : 내용 손상되지 않도록 무결성 보장

백업과 복구 : 파일 보호를 위한 백업, 복구 작업

암호화 : 악의적인 접근으로부터 보호



#### 파일이란?

일반적인 사용자 입장에서 읽고 쓸 수 있는 가장 작은 단위



#### 파일의 분류와 확장자

| 파일            | 확장자             | 비고                    |
| --------------- | ------------------ | ----------------------- |
| 실행파일        | exe, com           | 유닉스는 확장자가 없다. |
| 소스코드 파일   | c, cpp             |                         |
| 라이브러리 파일 | lib, a, dll        |                         |
| 배치 파일       | bat, sh, csh       |                         |
| 문서 파일       | txt, doc, pdf, hwp |                         |
| 동영상 파일     | avi, mkv, asf      |                         |
| 음악 파일       | wav, mp3, aac      |                         |
| 이미지 파일     | bmp, gif, jpg, png |                         |
| 압축 파일       | zip, rar           |                         |



#### 파일 속성 (운영체제마다 다름)

| 속성          | 특징             |
| ------------- | ---------------- |
| name          | 파일의 이름      |
| type          | 파일의 종류      |
| size          | 파일의 크기      |
| time          | 파일의 접근 시간 |
| location      | 파일의 위치      |
| accessibility | 파일의 접근 권한 |
| owner         | 파일의 소유자    |

  

#### 접근 방법

1. 순차 접근 (Sequential Access)

   <img width="708" alt="8" src="https://user-images.githubusercontent.com/76573337/144401877-e0fcbd36-1289-4f3c-a88b-a9dc5e520c2a.png">

2. 직접 접근 (Direct Access)

   <img width="712" alt="5" src="https://user-images.githubusercontent.com/76573337/144401602-4eaaf3e3-776f-4481-87b7-f98b9c8c1b8e.png">

3. 인덱스 접근

   ![7](https://user-images.githubusercontent.com/76573337/144401852-0eba9672-ad4d-4201-aad4-9e7070f904cb.png)



## 디렉터리의 구조

#### 디렉터리란?

관련 있는 파일을 하나로 모아놓은 곳 : 1개 이상의 자식 디렉터리를 가질 수 있고, 1개 이상의 파일을 가질 수 있다.



#### 1단계 디렉터리 구조

초기 파일 시스템

디렉터리 안에 자식 디렉터리를 만들 수 없다.

![6](https://user-images.githubusercontent.com/76573337/144401668-61586b05-1d1f-46a8-90bd-af99c2be2406.png)



#### 2단계 디렉터리 구조

사용자에게 개별적인 디렉터리를 만들어줌

![1](https://user-images.githubusercontent.com/76573337/144401424-e90f2a60-345a-42e7-b21e-8c08cefa9150.png)



#### 트리 디렉터리 구조

단계 확장에 제약이 없고 디렉터리에 파일과 디렉터리를 둘 다 저장할 수 있다.

![2](https://user-images.githubusercontent.com/76573337/144401477-ade3d091-2913-470e-9c78-47431ae43d62.png)



#### 그래프 디렉터리 구조

윈도우의 바로가기 같은 링크가 있어서 디렉터리와 디렉터리를 연결하기도 함 => 순환이 있다.

![4](https://user-images.githubusercontent.com/76573337/144401561-181b0623-55d2-495d-96b2-aa7338874a46.png)



#### 파일 시스템 마운트

파티션 : 논리적인 디스크 분할, 하나 또는 여러 개의 디스크를 파티션으로 나누어 사용할 수 있다.

Ex) 윈도우의 C, D, E 드라이브



#### 디스크 할당 방식

1. 연속할당

   파일을 구성하는 데이터를 디스크상에 연속적으로 배열

   

2. 불연속 할당

   비어 있는 블록에 데이터를 분산하여 저장, 이에 관한 정보를 파일 시스템이 관리

   연결 리스트 이용 or 인덱스 이용

   

#### 디스크의 빈 공간 관리

디스크 내부 단편화 줄이고 빈 공간을 효율적으로 관리하기 위해 파일 시스템은 빈 블록의 정보만 모아놓은 빈 공간 리스트를 유지한다.

디스크에 빈 공간이 생기면 빈 공간 리스트에 추가되고, 빈 공간 리스트를 보고 새로운 블록을 할당할 때는 리스트에 먼저 들어온 블록부터 할당한다.