# 가상메모리(VM != Virtual Machine)

* 다중 프로그래밍 = 많은 프로세스를 동시에 메모리에 올려야함.
* 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하도록 하는 기법.
* 물리 메모리보다 프로그램이 커도 된다.
* 메모리 오버레이 기법에서 나머지를 관리하기 위한 공간
* 보통 SSD로 C드라이브가 아닌 D드라이브 등에 가상메모리를 설정하는게 좋음.
* 만약 C가 SSD고 D가 HDD면 그냥 C에 설정.
* 윈도우 가상메모리 파일 이름은 pagefile.sys

<br>

## 개발 배경

* 가상메모리 이전 : 모든 코드는 물리메모리에 존재. 메모리 용량보다 큰 프로그램 실행 불가.
* 용량의 한계, 페이지 교체 등 성능이슈. 가끔 사용하는 코드가 항상 메모리에 올라올 필요 x

<br>

### 가상 메모리를 사용하면?

* 물리 메모리 크기에 제약 받지 않음.
* 더 많은 프로그램 동시 실행 가능.
* 응답 시간 유지, CPU 이용률, 처리율 상승
* swap에 필요한 입출력이 줄어들기 때문에 실행이 빨라짐.(context switch, kernel 개입 최소화)

> swap은 메모리 공간 부족을 해소하기 위해 주 기억장치와 보조 기억장치로 프로세스를 불러오고 내보내는 행위.

<br>

<br>

## 가상 메모리가 하는 일.

* 물리 메모리 + 논리 메모리로의 분리. 작은 메모리로 큰 가상 주소 공간을 프로그래머에 제공.

<br>

#### 가상 주소 공간

* 한 프로세스가 메모리에 저장되는 논리적인 공간.
* 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로써
* 현재 필요하지 않은 메모리 공간은 실제 물리 메모리에 올리지 않음.

| `Stack` | free (60KB) | `Heap` | `Data` | `Code` |

<br>

#### 프로세스간 페이지 공유.

> 가상메모리의 역할

* 시스템 라이브러리가 여러 프로세스 사이에 공유될 수 있도록 한다.
* 각 프로세스는 공유 라이브러리를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만
* 사실 라이브러리가 실제 올라간 물리 메모리 페이지들은 모든 프로세스가 공유하는 형태이다.
* 프로세스들은 공유 메모리를 통해 통신한다.
* `fork()`를 통한 프로세스 생성 과정에서 페이지들이 공유하는걸 가능하게 한다.

<br>

### Demand Paging(요구 페이징)

* 프로그램 실행 시작 시 초기에 필요한 것들만 물리 메모리에 적재하는 전략.
* 대개 페이지로 관리.

> 페이징: 하나의 프로세스가 사용하는 메모리 공간은 연속적일 필요 없다.
>
> 물리 메모리는 frame이라는 고정크기로 분리, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.
>
> 연속되어 저장되지 아니하고 물리 메모리의 남는 프레임에 적절히 배치된다.
>
> 하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어 논리메모리에서 관리되고 개별 페이지는 순서에 상관없이 물리메모리의 frame에 mapping되어 저장된다.
>
> **고정크기**의 블록이기 때문에 페이지크기 10에 33이 요구되면 4페이지의 마지막에 7이 남는 내부 단편화가 발생할 수 있다.

* 가상 메모리에서 필요해질 때 페이지가 적재된다. 즉 접근되지 않은 페이지는 물리메모리에 적재x

<br>

### 페이지 교체

* 모든 항목이 물리메모리에 없기 때문에 프로세스가 필요한 페이지 요청 간 page fault(페이지 부재) 가 일어날 수 있고 이때 원하는 페이지를 보조저장장치에서 swap-in해 가져오게 된다. (반대로 가상메모리로 페이지를 가져가는 것은 swap-out) - swap하는 비용은 성능 저하를 야기하기 때문에 메모리 여유율을 유지하는 것이 성능에 중요함.
* 이때 물리 메모리가 모두 사용중이면 페이지 교체가 이루어지거나 프로세스 강제 종료가 일어난다.

<br>

#### 과정

1. 디스크에서 필요한 페이지 위치를 찾음
2. 빈 페이지 프레임을 찾음
   * 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고름
   * 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정
4. 사용자 프로세스 재시작.

<br>

#### 페이지 교체 알고리즘(메인메모리 frame이 가득찼을 때 운영체제가 관리)

* FIFO(First-In First-Out)
  * 이해와 구현이 쉽다.
  * 오래된 페이지가 항상 불필요한 정보를 포함하는 것은 아니다.
  * 자주쓰이는 페이지를 교체시켜 부재율이 높아질 수 있다.
  * Belady의 모순: 페이지 프레임의 갯수를 늘려도 페이지 부재가 더 많이 발생하게 된다.
* OPR(Optimal Page Replacement)
  * 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체.(Belady의 모순이 발생 x)
  * 가장 낮은 페이지 부재율
  * 구현이 어려움(모든 프로세스 메모리 참조 계획을 미리 알아야 가능(신만 가능))
* LRU(Least Recently Used)
  * 가장 오래 사용되지 않은 페이지를 선택해 교체
  * FIFO < LRU < OPT
* LFU(Least Frequently Used)
  * 참조횟수가 가장 적은 페이지 교체(자주쓰이면 미래도 많이 쓰일 것이다.)
  * 특정 체이지를 집중적으로 사용. 그러나 다른 기능을 사용할때 안써도 되는데 계속 메모리에 머물러 초기 가정이 어긋날 수 있음.
  * 최적(OPT) 페이지 교체를 제대로 근사할 수 없어 잘 안쓰임
* MFU(Most Freaquently Used)
  * 참조 횟수가 가장 작은 페이지가 최근에 올라오면 앞으로 계속 사용될 것이다.라는 가정
  * LFU와 비슷하게 잘 안쓰임.

* clock Algorithm

  * 각 page마다 상태 bit0, 1을 가지고 교체되면 한바퀴 돌면서 1은 0으로 0은 교체 대상이 되는 알고리즘

  ![image-20211021045541439](가상메모리.assets/image-20211021045541439.png)

  * TLB의 도움을 받음.

![image-20211021045623983](가상메모리.assets/image-20211021045623983.png)

* 변경사항 반영 등 모두 운영체제가 담당함.





## Thrashing

![image-20211021045730049](가상메모리.assets/image-20211021045730049.png)

* frame이 가득차면 page fault가 일어나고 swap이 일어남. 이때 CPU가 놀게됨.
* 그럼 운영체제는 더 많은 프로세스를 메모리에 불러옴(악순환.)\
* 이를 해소하기 위해 Working set알고리즘과 Page Fault Frequency 알고리즘 사용.
* working set은 특정 시간마다 page갯수를 파악하고 그만큼 frame이 비면 교체를 진행( set단위로)
* frame이 가득하면 또 working-set단위로 쫓아냄

![image-20211021050021756](가상메모리.assets/image-20211021050021756.png)

* PFF는 page fault 비율에 따라 지급하는 Frame갯수을 조정함. 부족하면 프로세스 단위로 쫓아냄



### 메모리 고갈시

![image-20211021050133518](가상메모리.assets/image-20211021050133518.png)

<br>

<br>

## 리눅스란?

* 리누스 토르발스가 개발한 OS
* 자유 소프트웨어와 오픈 소스 개발의 표본
* 다중 사용자, 다중 작업(멀티 테스킹), 다중 스레드를 지원하는 네트워크 운영 체제(NOS)

* 즉 서버에 적합한 운영체제이다.

<br>

## 메모리란?

* 넓은 의미로 기억 장치 전부

* 좁은 의미로 메인 메모리(RAM)

* 컴퓨터의 유일한 작업공간.(프로세스는 cpu에서 실행x 반드시 메모리에 적재 후 실행 가능)

* 주소덩어리이며 주소로 인덱싱하는 커다란 배열.

* 컴퓨터가 켜지면 메모리에 운영체제나 프로세스들이 적재되고 CPU를 점유할 기회를 노림.

* 메모리의 코드 -> 컴파일러(코드 주소 결정) -> CPU

  > Symbolic Address : 메서드, 변수 등 코드
  >
  > Logical Address : 컴파일러가 변환시킨 숫자주소
  >
  > 각 프로그램마다 중복되는 논리주소를 가지고 있기때문에 가상주소라고도 부름

![image-20211021043730332](가상메모리.assets/image-20211021043730332.png)

* 논리주소 앞에 식별주소를 추가시킨 물리주소를 가지고 메모리에 적재.
* 하지만 CPU는 어떤 프로세스인지 알 필요 없기때문에 논리주소만 읽음.

![image-20211021044044312](가상메모리.assets/image-20211021044044312.png)

* MMU(memory Management Unit)은 base register, 산술계산기, limit register가 존재.(하드웨어)
* CPU가 처리한 논리주소에 base register에 적힌 시작 주소를 더해 프로세스로 반환함.
* 그리고 이것의 타당성 여부는 Limit register가 판단함.

![image-20211021044358471](가상메모리.assets/image-20211021044358471.png)

* 메모리 할당, swapping어떻게 할꺼냐?

![image-20211021044447025](가상메모리.assets/image-20211021044447025.png)

* 페이징 기법. -> 순서 보장x, mmu 연산도 복잡

![image-20211021044547741](가상메모리.assets/image-20211021044547741.png)

* paging table로 frame을 mapping함.(block map table-BMT)
* 행은 프로그램을 일정 크기로 자른 것. 프로그램당 행이 100만개.
* 이걸 CPU에 다 넣을 수 없음. 메모리에 page table을 저장해야함.
* valid, invalid는 메인메모린지, swap공간에 있는지 판단하는 bit.(어딨는지 인덱싱으로 검사함.)
* 물리 메모리공간 부족. -> 공통되게 사용하는 부분: read-only권한이 부여된 Shared Page로 사용함.

* 테이블과 page가 둘다 메모리에 있기땜누에 CPU는 조회를 위해 두번 접근해야함(두배로 느려짐)
* 이것을 해결하기 위한것이 TLB(Translation Look-aside Buffers) 캐시 메모리(하드웨어)
* TLB에 있는 주소라면 바로 Frame주소로 변환해 table을 부르지 않고 바로 page에 접근함.

<br>

## 리눅스 메모리 관리란?

* 리눅스가 메인 메모리(RAM)을 운영하는 방법을 총칭

* 작업공간을 필요로 하는 프로세스들을 위해 운영체제인 리눅스가 메인 메모리를 관리, 운영
* 가상메모리로 프로세스를 속이거나 하드디스크 입출력을 관리함.(프로세스는 운영체제에 속아 자신이 온전히 메모리에 있는줄 알고있음.)
* swap을 위한 입출력은 운영체제가 담당함.

* Linux는 보조메모리로 하드디스크나 SSD같은 보조 기억장치를 사용함.
* 실제 디스크를 마치 메모리처럼 사용하는 것을 `가상 메모리`라 하며 프로세스 입장에서는 디스크 공간이 아닌 실제 메모리로 인식.

* 리눅스에서 페이지는 4KB 단위.
* vmstat명령어로 메모리 사용률과 스왑아웃 발생빈도를 모니터링가능.(성능 최적화를 위해)

![image-20211021042309122](가상메모리.assets/image-20211021042309122.png)

* free는 사용가능한 메모리량
* so는 swap-out
* vmstat [딜레이] [횟수] 로 출력 조절 가능. 횟수 생략하면 무한으로 출력됨.
* vmstat 1 >> log.txt 명령을 통해 리다이렉션을 걸면 파일 로그를 남길 수 있음

<br>

### 파일 캐시

* vmstst의 memory
* swpd는 사용하는 가상메모리 량. free는 사용가능한 메인메모리량
* buff, cashe는 파일 I/O 작업 발생을 막기위해 저장하는 곳.(파일 I/O는 디스크 리소스이므로 느림)
* buff는 파일 시스템의 meta-data와 관련된 블록들을 저장하는 캐시
* cache는 파일의 내용을 저장하는 캐시
* WAS서버의 파일 캐시 성능 개선 사례는 거의 의미가 없는 수준
* 때문에 파일 캐시는 전체 메모리 대비 최대 30%이하로 유지하는 것을 권고.
* DB 서버도 자체 파일캐시를 운용하기 때문에 작은 파일 캐시 설정을 권고.

<br>

<br>

## 더 공부할 것.

* 실무로 배우는 시스템 성능 최적화, 공룡책
* 이화여대 반효경 교수님 운영체제 강의
* virtual machine과 docker도 궁금.
* https://www.youtube.com/watch?v=W8q3TKB9Lbo
* https://www.youtube.com/watch?v=YCfP9I4K-8Y

<br>

<br>

## Reference

* https://www.youtube.com/watch?v=qxmdX449z1U
* https://www.youtube.com/watch?v=Q2eauw81Pkk

